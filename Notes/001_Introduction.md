# Introduction

```txt
Fairy tales are more than true: not because they tell us that dragons exist, but because they tell us that dragons can be beaten.
    - G.K. Chesterton by way of Neil Gaiman, Coraline

```

- Proofs as programs: [Curry–Howard correspondence](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)

## Why to Learn this Stuff?

- For every successful general-purpose language, there are a thousand successful niche ones. Which are known as "little languages" or "domain-specific languages". eg: Scripting languages, template engines, markup formats, and configuration files.

- Learning to create a language puts you in creators shoes.

- Languages are great exercise: Implementing a language is a real test of programming skill. The code is complex and performance critical. You must master recursion, dynamic arrays, trees, graphs, and hash tables. You probably use hash tables at least in your day-to-day programming, but do you really understand them? Well, after we’ve crafted our own from scratch, I guarantee you will.

- Confidence we get after learning the ART!!

## Everything is Coded!!

Many other language books and language implementations use tools like Lex and Yacc(yet another compiler compiler), so-called compiler-compilers, that automatically generate some of the source files for an implementation from some higher-level description. There are pros and cons to tools like those, and strong opinions—some might say religious convictions—on both sides.

We will abstain from using them here. I want to ensure there are no dark corners where magic and confusion can hide, so we’ll write everything by hand. As you’ll see, it’s not as bad as it sounds, and it means you really will understand each line of code and how both interpreters work.

- Note: This is not a clean code guide, so it would not fit the coding standards of real world. This is done as books have their own constraints.
